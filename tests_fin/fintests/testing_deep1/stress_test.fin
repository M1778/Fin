// ============================================================
// 1. SETUP & UTILS
// ============================================================

fun print_header(msg: <string>) <noret> {
    printf("\n=== %s ===\n", msg);
}

fun assert(cond: <bool>, msg: <string>) <noret> {
    if (!cond) {
        printf("ASSERTION FAILED: %s\n", msg);
        blame msg;
    } else {
        printf("  [OK] %s\n", msg);
    }
}

// ============================================================
// 2. INTERFACES & POLYMORPHISM
// ============================================================

interface Printable {
    pub fun to_string() <string>;
}

struct User : <Printable> {
    id <int>,
    name <string>,
    
    fun to_string(self: <Self>) <string> {
        return self.name;
    }
}

struct Product : <Printable> {
    sku <int>,
    
    fun to_string(self: <Self>) <string> {
        return "Product";
    }
}

// ============================================================
// 3. MONOMORPHIZATION (Default Generics)
// ============================================================
// The compiler generates a unique version of this for every T.
// Fast, specific, no boxing.

struct Point<T> {
    x <T>,
    y <T>
}

fun swap_points<T>(p1: <&Point<T>>, p2: <&Point<T>>) <noret> {
    // Auto-dereference allows us to use .x on pointers directly
    let temp_x <T> = p1.x;
    let temp_y <T> = p1.y;
    
    p1.x = p2.x;
    p1.y = p2.y;
    
    p2.x = temp_x;
    p2.y = temp_y;
}

// ============================================================
// 4. TYPE ERASURE (Java Style)
// ============================================================
// Triggered by the 'Castable' constraint.
// The compiler generates ONE function. T is compiled as i8*.
// We must cast T to a concrete type to use it.

// Dummy interface to trigger ERASED mode in compiler
// interface Castable {} 

struct Box<T> {
    val <T>
}

fun print_erased<T: Castable>(item: <T>) <noret> {
    // At runtime, 'item' is just a pointer (i8*).
    // We simulate runtime type checking or assume type.
    
    // Test: Unboxing/Casting
    // We assume T is 'User' for this test
    if (@hasattr(item, "name")) {
        let u <User> = std_conv<User>(item);
        printf("  [ERASED] User Name: %s\n", u.name);
    } else {
        printf("  [ERASED] Unknown Object\n");
    }
}

// ============================================================
// 5. MANUAL MEMORY (Smart Pointer)
// ============================================================

struct SmartPtr {
    ptr <&int>,

    struct(val: <int>) {
        // Simulate 'new int'
        let p <&int> = std_conv<&int>(malloc(8)); 
        *p = val;
        self.ptr = p;
    }

    fun get(self: <Self>) <int> {
        return *self.ptr;
    }

    fun release(self: <Self>) <noret> {
        if (self.ptr != null) {
            printf("  [MEM] Releasing memory...\n");
            free(self.ptr);
            self.ptr = null; // This triggered the crash before!
        } else {
            printf("  [MEM] Already released.\n");
        }
    }
}

// ============================================================
// 6. MAIN
// ============================================================

fun main() <noret> {
    print_header("TEST 1: Monomorphization");
    let p1 <Point<int>> = Point<int>{x: 10, y: 20};
    let p2 <Point<int>> = Point<int>{x: 30, y: 40};
    swap_points(&p1, &p2);
    assert(p1.x == 30, "Swap Int");

    print_header("TEST 2: Type Erasure (Castable)");
    let u1 <User> = User{id: 1, name: "Alice"};
    // Pass User struct to Erased function. 
    // Compiler should box 'u1' into i8* and pass it.
    print_erased(u1);

    print_header("TEST 3: Memory Management");
    let smart <SmartPtr> = SmartPtr(999);
    assert(smart.get() == 999, "Ptr Value");
    smart.release();
    smart.release(); // Double free check

    print_header("TEST 4: Operator Overloading");
    // Re-using the logic from previous tests implicitly via struct usage
    // (Assuming MyStruct logic from lib.fin is available or we define it here)
    // For brevity, we trust the previous test for operators.
    
    printf("Done.\n");
}