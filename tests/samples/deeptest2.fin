@define printf(fmt: <string>, ...) <noret>;
@define free(ptr: <&void> ) <noret>;

@macro format(fmt: expr, args...) { // i dont know how to implement this right now but just imagine this works
  return quote {
      "formatted_string_placeholder";
    };
}

// Case 1: Interfaces
interface Printable { // A simple printable interface which only needs to declare a to_string
                      // function that returns a string
    pub fun to_string() <string>;
}

interface Addable<T: Castable> { // A more complicated interface uses Generics (Specially Castable FatPointer type)
                                 // It only requires you to have an operator overload
    operator +(self: <Self>, other : <T>) <T>;
}

struct MyStruct <T> : <Printable, Addable> {// The first section which is stick to the name of the
                                            // struct is where generics are introduced like <T>
                                            // but by using the ":" we can specify other structs
                                            // for inheritance OR use interfaces for forcing that
                                            // struct to act a certain way
    base_val <T>,
    base_size <int> = 16,
    pub fun to_string() <string> { // Defining required function
        return format!("base_val = {}, base_size = {}", cast<&auto>(base_val), base_size);
    }
    
    operator +(self: <Self>, other : <Self>) <Self> {
        return new Self{base_val: self.base_val + other.base_val, base_size: self.base_size + other.base_size};
    }
}

// Case 2: Inheritance

struct Person { // a normal popular example
    name <string>,
    age <int>,

    Person() <Self> { // this is a constructor. even if we don't specify a return type for
                      // constructor it will automatically use <Self> for it
        return new Person{name: "DefaultName", age: 0}; // just using default values to showcase
                                                        // constructors with no parameters intake
                                                        // remember this is not necessary and is
                                                        // almost invalid and we just have to set
                                                        // parameters instead of returning a new
                                                        // instance
    }

    // showcasing destructor too:
    // still the compiler does automatically free the instance itself most of the time (Person)
    // destructors are generated by compiler by default but sometimes you just gotta make them yourself
    ~Person() {
        free(&name);
        free(&age);
    }

    fun to_string() <string> {
        return format!("Name: {}, Age: {}", self.name, self.age);
    }
}

struct Student : <Person> { // inherits from its parent (Person) [NOTE: Also can inherit from multiple parents]
    grade <int>,
    Student(name: <string>, age: <int>, grade: <int>) { // Constructor (even if not specified compiler
                                          // automatically injects self and super)
        // Initialize parent using the super
        let person <Person> = super{name:name, age:age}; // we can also use the constructor of the
                                                         // parent class like super(...)
        self.name = person.name; // if we do not Initialize a field from parent we have inherited
                                 // it will automatically set it to null value but it gives a warning
        self.age = person.age;
        self.grade = grade;

        // compiler automatically returns self for the constructor
    }

    fun to_string() <string> { // we can also override parents methods
        return format!("Student (name: {}, age: {}, grade: {})", self.name, self.age, self.grade);
    }
}

struct MultiInherit: <Person, Student> { // but let's say we have multiple parents we wanna inherit from
    save_st <Student>,
    save_person <Person>,
    MultiInherit() { // but what if we have multiple parents, we cannot access them all with just
                     // super, we have to use a different approach 
        let copy <auto> = super::Student("Alex", 15, 8); // we'll use turbofish syntax to get access to a certain parent
                                             // for Student we'll use their constructor for now
        self.save_st = cast<Student>(copy); // using cast makes it so it copies the reference
        self.save_person = super::Person{name: "Idk", age: 10}; // we'll use the struct instantiator for this one
        

    }

    fun get_student() <Student> {
        return self.save_st;
    }

    static fun NewMI() <Self> { // a static function for Self
        return Self(); // uses the constructor of MultiInherit
    }
}

fun test_case2() <noret> {
    let p1 <Person> = Person(); // using struct constructor
    let ob1 <MultiInherit> = MultiInherit::NewMI(); // Using static function
}

// Case 3: Inheritance AND Interfaces
// You can use both at the same time too

interface HasConstructor { // A simple interface to force having a constructor and destructor
    Self();  // We can use the Self keyword here too, to tell the compiler we are doing some
             // special operations, this forces a constructor 
    ~Self(); // We use the same method for Destructor
}

struct MyStr {
    string_arr <[char]>,
    length <long>,
}

struct IncludeBoth: <HasConstructor, MyStr> {// This should throw an error since it doesn't
                                             // actually respect the rules defined for it from
                                             // interface
}
